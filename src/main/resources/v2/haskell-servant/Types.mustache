{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-unused-imports #-}
{-# LANGUAGE InstanceSigs #-}

module {{title}}.Types ({{#models}}{{#model}}{{#if vendorExtensions.x-arr}}{{else}}
  {{classname}} (..),{{/if}}{{/model}}{{/models}}
  ) where

import Data.Time.Calendar (Day)
import Data.Time.Clock.POSIX (POSIXTime)
import Data.Char (toLower)
import Data.List (stripPrefix)
import Data.Maybe (fromMaybe)
import Text.Read (readMaybe)
import Data.Aeson (Value, FromJSON(..), ToJSON(..), genericToJSON, genericParseJSON, withText)
import Data.Aeson.Types (Options(..), defaultOptions, Parser)
import Data.Text (Text, unpack)
import qualified Data.Text as T
import qualified Data.Map as Map
import GHC.Generics (Generic)
import Data.Function ((&))
import Network.HTTP.Types (Status(..){{#each status}}, status{{statusCode}}{{/each}})
import Servant.Checked.Exceptions (ErrStatus(..))
{{#imports}}import {{import}}
{{/imports}}

{{#apiInfo}}{{#if status}}-- common status code{{/if}}{{#each status}}
data {{name}} = {{name}} deriving (Eq, Read, Show)
instance ToJSON {{name}} where
  toJSON :: {{name}} -> Value
  toJSON _ = toJSON . show $ "{{& errMessage}}"
instance FromJSON {{name}} where
  parseJSON :: Value -> Parser {{name}}
  parseJSON = withText "{{name}}" $
    maybe (fail "could not parse as {{name}}") pure . readMaybe . unpack
instance ErrStatus {{name}} where
  toErrStatus :: {{name}} -> Status
  toErrStatus _ = status{{statusCode}}
{{/each}}{{/apiInfo}}
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{#if vendorExtensions.x-ad-hocStatus}}-- ad-hoc status code{{/if}}{{#each vendorExtensions.x-ad-hocStatus}}
data {{name}} = {{name}} deriving (Eq, Read, Show)
instance ToJSON {{name}} where
  toJSON :: {{name}} -> Value
  toJSON _ = toJSON . show $ "{{& errMessage}}"
instance FromJSON {{name}} where
  parseJSON :: Value -> Parser {{name}}
  parseJSON = withText "{{name}}" $
    maybe (fail "could not parse as {{name}}") pure . readMaybe . unpack
instance ErrStatus {{name}} where
  toErrStatus :: {{name}} -> Status
  toErrStatus _ = status{{statusCode}}
{{/each}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

{{#models}}{{#model}}{{#if vendorExtensions.x-errType}}{{else}}{{#if vendorExtensions.x-arr}}{{else}}
-- | {{description}} {{operationId}}
{{^vendorExtensions.x-customNewtype}}{{^parent}}{{vendorExtensions.x-data}} {{classname}} = {{classname}}
{{#vars}}{{#if @first}}  { {{else}}  , {{/if}}{{& name}} :: {{datatype}} -- ^ {{& description}}
{{/vars}}  }deriving (Show, Eq, Generic)
instance FromJSON {{classname}} where
  parseJSON = genericParseJSON (removeFieldLabelPrefix "{{vendorExtensions.x-prefix}}")
instance ToJSON {{classname}} where
  toJSON = genericToJSON (removeFieldLabelPrefix "{{vendorExtensions.x-prefix}}")
{{/parent}}{{#parent}}
newtype {{classname}} = {{classname}} { un{{classname}} :: {{parent}} }
  deriving (Show, Eq, FromJSON, ToJSON, Generic)
{{/parent}}{{/vendorExtensions.x-customNewtype}}{{#vendorExtensions.x-customNewtype}}
newtype {{classname}} = {{classname}} {{vendorExtensions.x-customNewtype}} deriving (Show, Eq, FromJSON, ToJSON, Generic)
{{/vendorExtensions.x-customNewtype}}{{/if}}{{/if}}{{/model}}{{/models}}
-- Remove a field label prefix during JSON parsing.
-- Also perform any replacements for special characters.
removeFieldLabelPrefix :: String -> Options
removeFieldLabelPrefix prefix =
  defaultOptions
  {fieldLabelModifier = fromMaybe (error ("did not find prefix " ++ prefix)) . headLower .  stripPrefix prefix . replaceSpecialChars}
  where
    headLower (Just (s:ss)) = Just $ (toLower s) : ss
    headLower _ = Nothing
    replaceSpecialChars field = foldl (&) field (map mkCharReplacement specialChars)
    specialChars =
      [ {{#specialCharReplacements}}("{{&char}}", "{{&replacement}}"){{#hasMore}}
      , {{/hasMore}}{{/specialCharReplacements}}
      ]
    mkCharReplacement (replaceStr, searchStr) = T.unpack . T.replace (T.pack searchStr) (T.pack replaceStr) . T.pack
